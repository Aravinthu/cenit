module Setup
  class Api
    include SharedEditable

    build_in_data_type.referenced_by(:name)

    field :name, type: String
    field :specification, type: String

    def cenit_collection_hash(options = {})
      self.class.swagger_to_cenit(specification, options)
    end

    class << self

      def swagger_to_cenit(spec, options = {})
        spec = Psych.load(spec)
        [
          definitions = spec['definitions'] || {},
          parameters = spec['parameters'] || {},
          paths = spec['paths'] || {}
        ].each do |schema_container|
          schema_container.each_deep_pair do |hash, key, value|
            if key == '$ref' && !(value.is_a? Hash)
              if value.start_with?(prefix = '#/definitions/') || value.start_with?(prefix = '#/parameters/')
                hash[key] = value.from(prefix.length)
              elsif value.start_with?('#/')
                hash[key] = value.from(2)
              else
                fail "ERROR: ref #{value} is not valid"
              end
            end
          end if schema_container
        end

        parameters.each { |param| fail "Parameter name conflict with definition: #{param}" if definitions.has_key?(param) }

        if definitions.size > 0
          definitions.each_pair do |name, schema|
            schema['type'] = 'object' if schema['properties'] && schema['type'].nil?
            schema['title'] = name
            if schema['type'].nil? && schema['properties'].nil?
              definitions.delete(name)
              puts "WARN: schema #{name} has no properties and type"
            elsif schema['type'] == 'object' && (properties = schema['properties'])
              properties.each do |property, property_schema|
                if (ref = property_schema['$ref'])
                  check_referenced_schema(ref, property_schema, definitions)
                elsif property_schema['items'].is_a? Hash
                  if property_schema['type'] == 'array' && (items_schema = property_schema['items']) && (ref = items_schema['$ref'])
                    check_referenced_schema(ref, property_schema, definitions)
                  end
                end
              end
            else
              puts "WARN: schema #{name} is not object with properties" if options[:notify_properties_no_object]
            end
          end
        else
          puts 'WARN: no definitions'
        end

        title = spec['info']['title']
        title += ' API' unless title.downcase['api']
        version = spec['info']['version']
        namespace = "#{title} #{version}".strip
        spec['shared'] = shared =
          {
            name: slugify(namespace),
            shared_version: '0.1',
            readme: 'These collection have been automatically generated by Cenit',
            title: namespace,
            summary: !spec['info']['description'].nil? ? spec['info']['description'] : spec['info']['title'],
            authors: [
              {
                name: User.current.name,
                email: User.current.email
              }
            ],
            category: 'API Collection'
          }

        # if !spec['info']['x-logo'].nil? && !spec['info']['x-logo']['backgroundColor'].nil?
        #   shared['logo_background'] = spec['info']['x-logo']['backgroundColor']
        # end

        shared['data'] = data = {}

        base_connections = {}
        multiple_schemes = spec ['schemes'].size > 1
        spec ['schemes'].each do |scheme|
          base_connections[scheme] =
            {
              namespace: namespace,
              name: multiple_schemes ? "#{scheme.upcase} Connection" : 'Connection',
              url: scheme + '://' + spec['host'] + (!spec['basePath'].nil? ? spec['basePath'] : '')
            }
        end

        data['connection_roles'] = connection_roles = []
        data['connections'] = connections = []

        authorizations = []
        current_oauth2_scopes = []
        if (security_definitions = spec['securityDefinitions'])
          multiple_security = security_definitions.size > 1
          security_definitions.each do |name, security|
            name = name.to_title
            pull_parameters = nil
            case security['type']
            when 'oauth2'
              data['authorizations'] = authorizations
              oauth2_provider = Setup::Oauth2Provider.where(authorization_endpoint: security['authorizationUrl']).first
              oauth_client = Setup::OauthClient.where(provider: oauth2_provider).first
              if oauth2_provider && oauth_client
                auth =
                  {
                    namespace: namespace,
                    name: "#{name} Authorization",
                    _type: 'Setup::Oauth2Authorization',
                    client: {
                      _reference: true,
                      name: oauth_client.name,
                      provider: provider_ref = {
                        _reference: true,
                        namespace: oauth2_provider.namespace,
                        name: oauth2_provider.name
                      }
                    },
                    scopes: scopes = []
                  }
                security['scopes'].each do |scope, description|
                  scopes << { _reference: true, name: scope }.merge(provider: provider_ref)
                  current_oauth2_scopes << { name: scope, description: description }.merge(provider: provider_ref)
                end
                authorizations << auth
              else
                fail "Unknown oauth2 config for authorization URL: #{security['authorizationUrl']}"
              end
            when 'apiKey'
              shared[:pull_parameters] = pull_parameters = []
              pull_parameters <<
                {
                  type: 'connection',
                  name: 'Connection',
                  label: 'API Key',
                  property: 'template_parameters',
                  key: 'api_key',
                  parameter: "On connection 'Connection' template parameter 'api_key'",

                  property_name: 'value',
                  location: {
                    connections: {
                      namespace: namespace,
                      name: 'Connection'
                    },
                    template_parameters: {
                      key: 'api_key'
                    }
                  }
                }
            when 'basic'
              data['authorizations'] = authorizations
              auth_basic = {
                namespace: namespace,
                name: "#{name} Authorization",
                _type: 'Setup::BasicAuthorization'
              }
              authorizations << auth_basic
            else
              fail "Unknown security schema: #{security['type']}"
            end

            base_connections.each do |scheme, base_connection|
              conn = base_connection.dup
              if multiple_security
                conn[:name] = "#{name} Connection"
              end
              if pull_parameters
                conn[:template_parameters] = [{ 'key': 'api_key', 'value': '' }]
              end
              connections << conn
              conn_role_name = 'Connections'
              conn_role_name = "#{name} #{conn_role_name}" if multiple_security
              conn_role_name = "#{scheme.upcase} #{conn_role_name}" if multiple_schemes
              connection_roles <<
                {
                  namespace: namespace,
                  name: conn_role_name,
                  connections: [{ _reference: true, namespace: namespace, name: conn[:name] }]
                }
            end
          end
        else
          puts 'WARN: No security definitions'
          base_connections.each do |scheme, base_connection|
            connections << base_connection
            connection_roles << { namespace: namespace, name: "#{scheme.upcase} Connections", connections: [{ _reference: true, namespace: namespace, name: base_connection[:name] }] }
          end
        end

        slugs = Set.new
        namespace_slug = slugify(namespace)
        data['namespaces'] = [
          name: namespace,
          slug: namespace_slug
        ]

        if definitions.size > 0 || parameters.size > 0
          data['snippets'] = snippets = []
          data['data_types'] = data_types = []
          {
            '': definitions,
            param_: parameters
          }.each do |slug_prefix, schemas|
            schemas.each do |name, schema|
              name = name.delete '$'
              slug = slug_prefix.to_s + slugify(name)
              fail "Slug already taken: #{slug}" unless slugs.add?(slug)
              data_type = Setup::JsonDataType.new namespace: namespace,
                                                  name: name,
                                                  slug: slug,
                                                  title: name.to_title
              data_type.schema = schema
              if data_type.validate_model
                data_type.snippet.namespace = namespace
                data_type.snippet.name = data_type.snippet_name
                data_type.snippet.type = :javascript
                snippets << data_type.snippet.share_hash
                data_types << data_type.share_hash
              else
                fails data_type.errors.full_messages.to_sentence
              end
            end
          end
        end

        default_consumes = spec['consumes'] || ['application/json']

        data['resources'] = paths.keys.collect do |path|
          path_parameters = { template_parameters: template_parameters = [] }.stringify_keys
          path_desc = paths[path]
          (path_desc.delete('parameters') || []).each do |param_desc|
            if param_desc.is_a?(Hash)
              if param_desc.size == 1 && (ref = param_desc['$ref']).is_a?(String)
                if (param = parameters[ref])
                  param
                else
                  fail "ERROR: Parameter reference not found: #{ref}"
                end
              else
                (path_parameters[LOCATION_MAP[param['in']] || 'parameters'] ||= []) << to_cenit_parameter(param_desc)
                #puts "ERROR: Invalid parameter description: #{param_desc.to_json}"
              end
            else
              fail "ERROR: Invalid parameter description type: #{param_desc.class}"
            end
          end
          operations = path_desc.keys.collect do |method|
            request_desc = path_desc[method]
            operation =
              {
                method: method.to_s.downcase,
                metadata: metadata = request_desc.reject { |k| %w(description parameters).include?(k) }.reverse_merge('consumes' => default_consumes)
              }
            if (description = request_desc['description'])
              operation[:description] = description
            end
            metadata[:template_parameters] = []
            (request_desc['parameters'] || []).each do |param|
              if (location = LOCATION_MAP[param['in']])
                if location == 'template_parameters'
                  metadata[:template_parameters]
                else
                  operation[location] ||= []
                end << to_cenit_parameter(param)
              end
            end
            operation
          end
          template_parameters = template_parameters.inject({}) { |h, p| h[p[:key]] = p; h }
          operations.each do |op|
            op[:metadata][:template_parameters].each do |p|
              template_parameters[p[:key]] =
                if (template_parameter = template_parameters[p[:key]])
                  template_parameter.intersection(p)
                else
                  p
                end
            end
          end
          operations.each do |op|
            op_template_parameters = []
            op[:metadata].delete(:template_parameters).each do |p|
              if (p = template_parameters[(key = p[:key])].difference(p)).present?
                p[:key] = key
                op_template_parameters << p
              end
            end
            if op_template_parameters.present?
              op[:metadata][:template_parameters] = op_template_parameters
            end
          end
          path_parameters['template_parameters'] = template_parameters.values.to_a
          {
            namespace: namespace,
            name: path.split('/').collect { |token| token.capitalize }.join(' ').strip,
            path: path.gsub('{', '{{').gsub('}', '}}'),
            operations: operations,
            _reset: :operations
          }.merge(path_parameters)
        end

        shared['data']['oauth2_scopes'] = current_oauth2_scopes unless current_oauth2_scopes.empty?
        if options[:shared_format]
          shared
        else
          [:name, :readme, :title].each { |key| shared['data'][key] = shared[key] }
          shared['data']
        end
      end

      private

      LOCATION_MAP =
        {
          header: 'headers',
          query: 'parameters',
          path: 'template_parameters'
        }.stringify_keys

      def check_referenced_schema(ref, container_schema, all_schemas)
        if (ref_schema = all_schemas[ref])
          if identificable?(ref, ref_schema)
            container_schema['referenced'] = true
          else
            puts "WARN: embedding #{ref}"
          end
        else
          fail "ERROR: ref #{ref} not found"
        end
      end

      def slugify(name)
        name = name.gsub(/ |\/|\.|:|-/, '_').gsub('+', 'plus').gsub('&', '_and_')
        name = name.split('_').collect do |word|
          if word.downcase.length > 10
            word.underscore
          else
            word.downcase
          end
        end.join('_').gsub(/_+/, '_')
        name.delete '(' ')' '[' ']' ',' '«' '»' ','
      end

      def to_cenit_parameter(param)
        {
          key: param['name'],
          value: param['default'] || '',
          description: param['description'],
          metadata: param.reject { |k| %w(name description in).include?(k) }
        }
      end

      def identificable?(name, schema)
        schema['type'] == 'object' && (properties = schema['properties']) && properties.has_key?('id')
      end
    end
  end
end